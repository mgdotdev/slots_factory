from copy import copy
from functools import update_wrapper

from types import FunctionType

from slots_factory.tools.SlotsFactoryTools import (
    _slots_factory_hash,
    _slots_factory_setattrs_slim,
)

from .initializers import (
    wrapped_frozen,
    wrapped_generic,
    wrapped_slim,
)

from .object_model_methods import (
    _frozen,
    _ordering_methods,
    __repr__,
    __len__,
    __eq__,
    __hash__,
    __iter__,
)


TYPEDEF_DICT_KEYS = {
    "__module__",
    "__annotations__",
    "__doc__",
    "__dict__",
    "__weakref__",
}


def slots_from_type(type_, **kwargs):
    """Convenience function. Takes a type and kwargs, and instantiates the type
    with kwargs assigned to corresponding attributes.

    :param type_: type as derived from type_factory()
    :type type_: type
    :return: instance of the type, with assigned attributes
    :rtype: SlotsObject
    """
    instance = type_()
    _slots_factory_setattrs_slim(instance, kwargs, False)
    return instance


def slots_from_dict(attrs={}, _name="SlotsObject", **kwargs):
    """function that returns a Python Python instance w/ __slots__ from a dict,
    allows for same kwargs as dataslots.
    
    :param attrs: dictionary template for setting attr values on returned
    instance
    :param _name: name of returned object
    :param **kwargs: options for type definition, mirrors those of @dataslots

    :return: SlotsObject instance
    :rtype: SlotsObject
    """
    if not kwargs.get("order"):
        kwargs["order"] = attrs.keys()
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        fast_slots.__dict__[_name] = type_factory(attrs.keys(), _name, **kwargs)
    return fast_slots(_name, **attrs)


def type_factory(args, _name="Slots_Object", **kwargs):
    """function that returns a new Python type w/ __slots__, and other dunder
    methods if specified.

    :param _name: name of the new type
    :type _name: str
    :param args: iterable (list, tuple) of strings that correspond to the
    attributes of the objects
    :type args: Iter[str, str...]

    :return: type definition defined by function arguments
    :rtype: type
    """
    methods = {
        "__slots__": args,
        "__iter__": __iter__,
        "__len__": __len__,
        "__eq__": __eq__,
        "__hash__": __hash__,
        "__repr__": __repr__,
    }

    frozen = kwargs.get("frozen")
    if frozen:
        methods.update({"__setattr__": _frozen, "__delattr__": _frozen})

    _order = kwargs.get("order")
    if _order:
        methods.update(_ordering_methods(args, _order))

    _docs = kwargs.get("__doc__")
    if _docs:
        methods.update({"__doc__": _docs})

    _methods = kwargs.get("_methods")
    if _methods:
        methods.update(**_methods)

    return type(_name, (), methods)


def slots_factory(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    id_ = _slots_factory_hash(_name, kwargs)
    type_ = slots_factory.__dict__.get(id_)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        slots_factory.__dict__[id_] = type_
    instance = type_()
    _slots_factory_setattrs_slim(instance, kwargs, False)
    return instance


def fast_slots(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__. Only uses
    name for caching, and makes a new object type when AttributeError is raised.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        fast_slots.__dict__[_name] = type_
    try:
        instance = type_()
        _slots_factory_setattrs_slim(instance, kwargs, True)
        return instance
    except AttributeError:
        del fast_slots.__dict__[_name]
        return fast_slots(_name, **kwargs)


def dataslots(_cls=None, **ds_kwargs):
    """provides a decorator for ingesting type definitions derived from `class`
    and returning a retyped definition which contains __slots__.

    :param _cls: object to be emulated
    :type _cls: type

    :param frozen: optional flag for ensuring data is immutable
    :type frozen: bool

    :return: wrapper functions
    :rtype: function
    """
    
    def wrapper(f):

        _attrs, _methods, _callables = {}, {}, {}

        _seen_keys = set()
        for (attr, collection) in (
            (attr, getattr(f, attr))
            for attr in ("__dict__", "__annotations__")
            if hasattr(f, attr)
        ):
            for k, v in collection.items():
                if k in TYPEDEF_DICT_KEYS or k in _seen_keys:
                    continue
                if isinstance(v, type) and attr == "__dict__":
                    _callables[k] = v
                elif isinstance(v, FunctionType):
                    if v.__name__ == "<lambda>":
                        _callables[k] = v
                    else:
                        _methods[k] = v
                elif isinstance(v, property):
                    _methods[k] = v
                else:
                    _attrs[k] = v
                _seen_keys.add(k)

        _ds_kwargs = {
            "__doc__": f.__doc__,
            "_methods": _methods,
            **wrapper.__dict__["ds_kwargs"],
        }

        _type = type_factory(
            list(_attrs.keys()) + list(_callables.keys()),
            f.__name__,
            **_ds_kwargs
        )

        _defaults = {key: getattr(f, key) for key in _attrs.keys() if hasattr(f, key)}

        if not wrapper.__dict__["ds_kwargs"].get("frozen", False):
            if not (_defaults or _callables):
                wrapped = wrapped_slim()
            else:
                wrapped = wrapped_generic()
        else:
            wrapped = wrapped_frozen()

        wrapped.__dict__["_type"] = _type
        wrapped.__dict__["_defaults"] = _defaults
        wrapped.__dict__["_callables"] = _callables

        return update_wrapper(wrapped, f)
    
    wrapper.__dict__["ds_kwargs"] = ds_kwargs
    if _cls is None:
        return wrapper
    return wrapper(_cls)

dataslots.__dict__["from_dict"] = slots_from_dict
